/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    // Apply the common convention plugin for shared build configuration between library and application projects.
    id 'io.aergo.heraj.java-common-conventions'

    // Apply the java-library plugin for API and implementation separation.
    id 'java-library'
    id 'jacoco'         // coverage
    id 'checkstyle'
    id 'maven-publish'           // maven
    id 'signing'                 //
    id "me.champeau.jmh"  // micro bmt
}

// FIXME 이 태스크는 별도의 자바독 모듈을 만들어서 처리하는 것이 좋을 듯 하다.
//task allcoverage(type: JacocoReport) {
//  def targetProjects = javaLibraryProjects.findAll {
//    it.name != 'annotation' && it.name != 'protobuf'
//  }
//  dependsOn = targetProjects.coverage
//  getSourceDirectories().setFrom(targetProjects.sourceSets.main.allSource.srcDirs)
//  getClassDirectories().setFrom(targetProjects.sourceSets.main.output.classesDirs)
//  getExecutionData().setFrom(targetProjects.jacocoTestReport.executionData)
//  reports {
//    html.enabled = true
//    xml.enabled = true
//    xml.destination file("${buildDir}/reports/jacoco/report.xml")
//    csv.enabled = false
//  }
//  afterEvaluate {
//    getClassDirectories().setFrom(classDirectories.files.collect {
//      fileTree(dir: it, exclude: ['types/**'])
//    })
//  }
//}

// FIXME 이 태스크는 별도의 자바독 모듈을 만들어서 처리하는 것이 좋을 듯 하다.
//task alljavadoc(type: Javadoc) {
//  def targetProjects = javaLibraryProjects.findAll {
//    it.name != 'protobuf'
//  }
//  source targetProjects.collect { it.sourceSets.main.allJava }
//  classpath = files(targetProjects.collect { it.sourceSets.main.compileClasspath })
//  destinationDir = file("${buildDir}/docs/javadoc")
//  if (JavaVersion.current().isJava8Compatible()) {
//    options.addStringOption('Xwerror', '-quiet')
//  }
//  if (JavaVersion.current().isJava9Compatible()) {
//    options.addBooleanOption('html5', true)
//  }
//}

def projectBaseName = 'heraj-' + project.name

/* maven-publish */
publishing {
  publications {
//    maven(MavenPublication) {
//      groupId = project.group
//      artifactId = projectBaseName
//      version = project.version
//
//      from components.java
//      artifact sourceJar
//      artifact javadocJar
//    }

    mavenJava(MavenPublication) {
      pom {
        groupId = project.group
        artifactId = projectBaseName
        version = project.version
        name = artifactId

        from components.java
        artifact sourceJar
        artifact javadocJar

        packaging = 'jar'
        // optionally artifactId can be defined here
        description = 'A java SDK for accessing blockchain Aergo.'
        url = 'https://github.com/aergoio/heraj'

        scm {
          connection = 'scm:git:https://github.com/aergoio/heraj.git'
          developerConnection = 'scm:git:https://github.com/aergoio/heraj.git'
          url = 'https://github.com/aergoio/heraj'
        }

        licenses {
          license {
            name ='MIT'
            url = 'https://github.com/aergoio/heraj/blob/develop/LICENSE.txt'
          }
        }

        developers {
          developer {
            id = 'hayarobi'
            name = 'Hayarobi Park'
            email = 'hayarobipark@gmail.com'
          }
          developer {
            id = 'acktsap'
            name = 'Taeik Lim'
            email = 'sibera21@gmail.com'
          }
          developer {
            id = 'bylee'
            name = 'bonyong lee'
            email = 'bylee78@gmail.com'
          }
        }
      }
    }

  }

  repositories {
    maven {
      def releasesRepoUrl = "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/"
      def snapshotsRepoUrl = "https://s01.oss.sonatype.org/content/repositories/snapshots/"
      url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
      credentials {
          username = project.hasProperty('ossrhUsername') ? ossrhUsername : "Unknown user"
          password = project.hasProperty('ossrhPassword') ? ossrhPassword : "Unknown password"
      }
    }
  }

}

signing {
    sign publishing.publications.mavenJava
}
//  tasks.withType(Sign) {
//      onlyIf { isReleaseVersion }
//  }

dependencies {
  compileOnly "org.projectlombok:lombok:${lombokVersion}"
  annotationProcessor "org.projectlombok:lombok:${lombokVersion}"

  implementation "org.slf4j:slf4j-api:${slf4jVersion}"
  runtimeOnly "ch.qos.logback:logback-classic:${logbackVersion}"

  testImplementation "org.projectlombok:lombok:${lombokVersion}"
  testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
  testImplementation "junit:junit:${junitVersion}"
  testImplementation "org.mockito:mockito-core:${mockitoVersion}"
  testImplementation("org.powermock:powermock-api-mockito2:${powerMockVersion}") {
    exclude group: 'org.mockito', module: 'mockito-core'
  }
  testImplementation "org.powermock:powermock-module-junit4:${powerMockVersion}"
}


/* checkstyle */

checkstyle {
  toolVersion checkstyleVersion
  sourceSets = [project.sourceSets.main]
  configFile = file("${project.rootProject.projectDir}/styles.xml")
}

task lint {
  dependsOn check
}


/* jacoco */

jacoco {
  toolVersion jacocoVersion
}

// need test task before executing
jacocoTestReport {
  group = "Reporting"
  getAdditionalSourceDirs().setFrom(sourceSets.main.allSource.srcDirs)
  getSourceDirectories().setFrom(sourceSets.main.allSource.srcDirs)
  getClassDirectories().setFrom(sourceSets.main.output.classesDirs)
  reports {
    xml.enabled true
    html.enabled true
    csv.enabled false
  }
}

task coverage {
  dependsOn jacocoTestReport
}


jar {
  archivesBaseName = projectBaseName
}


/* jmh */
jmh {
  fork = 2
  benchmarkMode = ['thrpt']
  resultFormat = 'JSON'
  timeUnit = 's'
  threads = 2 * Runtime.runtime.availableProcessors()
//    jmhVersion = '1.21'
  duplicateClassesStrategy = org.gradle.api.file.DuplicatesStrategy.WARN
}
